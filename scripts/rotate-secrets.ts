#!/usr/bin/env tsx
/**
 * üîÑ Secrets Rotation Script  
 * Automatise la rotation mensuelle des secrets et cl√©s API
 */

import { randomBytes, createHash } from 'crypto'

interface SecretMetadata {
  name: string
  lastRotated: string
  expiresAt: string
  rotationInterval: number // days
  isExpired: boolean
  isRequired: boolean
}

interface RotationResult {
  secret: string
  success: boolean
  oldValue?: string
  newValue?: string
  error?: string
  timestamp: string
}

class SecretsRotator {
  private results: RotationResult[] = []
  private readonly ROTATION_SCHEDULE = {
    'MONGODB_URI': 90, // 3 months
    'CLAUDE_API_KEY': 30, // monthly
    'OPENAI_API_KEY': 30, // monthly
    'DEEPSEEK_API_KEY': 60, // 2 months
    'GEMINI_API_KEY': 60, // 2 months
    'GITHUB_TOKEN': 90, // 3 months
    'CLOUDFLARE_TOKEN': 180, // 6 months
    'SENTRY_AUTH_TOKEN': 365, // yearly
    'ENCRYPTION_KEY': 30, // monthly - critical
    'JWT_SECRET': 30, // monthly - critical
  }

  async rotateAllSecrets(): Promise<RotationResult[]> {
    console.log('üîÑ Starting automated secrets rotation...\n')

    const secrets = Object.keys(this.ROTATION_SCHEDULE)
    
    for (const secretName of secrets) {
      await this.rotateSecret(secretName)
    }

    return this.results
  }

  private async rotateSecret(secretName: string): Promise<void> {
    console.log(`üîë Processing ${secretName}...`)

    try {
      const metadata = await this.getSecretMetadata(secretName)
      
      if (!metadata.isExpired) {
        console.log(`  ‚è≠Ô∏è  Not expired yet (expires ${metadata.expiresAt})`)
        this.results.push({
          secret: secretName,
          success: true,
          timestamp: new Date().toISOString()
        })
        return
      }

      console.log(`  üîÑ Rotating expired secret...`)
      
      const oldValue = await this.getCurrentSecretValue(secretName)
      const newValue = await this.generateNewSecretValue(secretName)
      
      // Update secret in GitHub repository
      await this.updateGitHubSecret(secretName, newValue)
      
      // Validate new secret works
      await this.validateNewSecret(secretName, newValue)
      
      console.log(`  ‚úÖ Successfully rotated ${secretName}`)
      
      this.results.push({
        secret: secretName,
        success: true,
        oldValue: this.maskSecret(oldValue),
        newValue: this.maskSecret(newValue),
        timestamp: new Date().toISOString()
      })

    } catch (error) {
      console.log(`  ‚ùå Failed to rotate ${secretName}: ${error.message}`)
      
      this.results.push({
        secret: secretName,
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()
      })
    }
  }

  private async getSecretMetadata(secretName: string): Promise<SecretMetadata> {
    const rotationInterval = this.ROTATION_SCHEDULE[secretName] || 90
    
    // In real implementation, this would check actual secret metadata
    // For now, simulate based on environment
    const mockLastRotated = new Date()
    mockLastRotated.setDate(mockLastRotated.getDate() - (rotationInterval + 5)) // Simulate expired
    
    const expiresAt = new Date(mockLastRotated)
    expiresAt.setDate(expiresAt.getDate() + rotationInterval)
    
    return {
      name: secretName,
      lastRotated: mockLastRotated.toISOString(),
      expiresAt: expiresAt.toISOString(),
      rotationInterval,
      isExpired: new Date() > expiresAt,
      isRequired: ['CLAUDE_API_KEY', 'OPENAI_API_KEY', 'ENCRYPTION_KEY', 'JWT_SECRET'].includes(secretName)
    }
  }

  private async getCurrentSecretValue(secretName: string): Promise<string> {
    // In real implementation, would fetch from secure storage
    return process.env[secretName] || 'mock-secret-value'
  }

  private async generateNewSecretValue(secretName: string): Promise<string> {
    switch (secretName) {
      case 'ENCRYPTION_KEY':
        // Generate 256-bit key
        return randomBytes(32).toString('base64')
        
      case 'JWT_SECRET':
        // Generate strong random secret
        return randomBytes(64).toString('base64url')
        
      case 'GITHUB_TOKEN':
        // GitHub tokens are generated manually
        throw new Error('GitHub tokens must be rotated manually in GitHub settings')
        
      case 'CLAUDE_API_KEY':
      case 'OPENAI_API_KEY':
      case 'DEEPSEEK_API_KEY':
      case 'GEMINI_API_KEY':
        // API keys are generated by providers
        throw new Error(`${secretName} must be rotated manually in provider dashboard`)
        
      case 'CLOUDFLARE_TOKEN':
        throw new Error('Cloudflare tokens must be rotated manually in Cloudflare dashboard')
        
      case 'MONGODB_URI':
        throw new Error('MongoDB connection strings should be rotated by changing passwords in Atlas')
        
      default:
        // Generate generic secure random value
        return randomBytes(32).toString('hex')
    }
  }

  private async updateGitHubSecret(name: string, value: string): Promise<void> {
    // In real implementation, would use GitHub API to update repository secrets
    console.log(`    üìù Updating ${name} in GitHub repository secrets...`)
    
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    if (!process.env.GITHUB_TOKEN) {
      throw new Error('GITHUB_TOKEN required for updating secrets')
    }
    
    // Mock GitHub API call
    const response = {
      ok: Math.random() > 0.1, // 90% success rate
      status: Math.random() > 0.1 ? 200 : 403
    }
    
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`)
    }
  }

  private async validateNewSecret(name: string, value: string): Promise<void> {
    console.log(`    üîç Validating new ${name}...`)
    
    // Simulate validation
    await new Promise(resolve => setTimeout(resolve, 500))
    
    // For encryption keys, test encryption/decryption
    if (name === 'ENCRYPTION_KEY') {
      const testData = 'test-data'
      const hash = createHash('sha256').update(value + testData).digest('hex')
      if (hash.length !== 64) {
        throw new Error('Invalid encryption key generated')
      }
    }
    
    // Random 5% failure rate for testing
    if (Math.random() < 0.05) {
      throw new Error('Validation failed - new secret not working')
    }
  }

  private maskSecret(secret: string): string {
    if (!secret || secret.length < 8) return '***'
    return secret.substring(0, 4) + '*'.repeat(secret.length - 8) + secret.substring(secret.length - 4)
  }

  generateReport(): void {
    console.log('\nüìä SECRETS ROTATION REPORT')
    console.log('=' .repeat(50))
    
    const successful = this.results.filter(r => r.success).length
    const failed = this.results.filter(r => !r.success).length
    
    console.log(`‚úÖ Successful rotations: ${successful}`)
    console.log(`‚ùå Failed rotations: ${failed}`)
    console.log(`üìä Total processed: ${this.results.length}`)
    console.log('')
    
    console.log('üìã Detailed Results:')
    for (const result of this.results) {
      const status = result.success ? '‚úÖ' : '‚ùå'
      console.log(`${status} ${result.secret}`)
      if (result.error) {
        console.log(`     Error: ${result.error}`)
      }
      if (result.newValue) {
        console.log(`     New value: ${result.newValue}`)
      }
    }
    
    console.log('')
    console.log('üîî Manual Actions Required:')
    console.log('  ‚Ä¢ Claude API: Rotate key in Anthropic Console')
    console.log('  ‚Ä¢ OpenAI API: Rotate key in OpenAI Platform')
    console.log('  ‚Ä¢ DeepSeek API: Rotate key in DeepSeek Console') 
    console.log('  ‚Ä¢ Gemini API: Rotate key in Google AI Studio')
    console.log('  ‚Ä¢ GitHub Token: Rotate in GitHub Settings > Developer settings')
    console.log('  ‚Ä¢ Cloudflare Token: Rotate in Cloudflare > My Profile > API Tokens')
    console.log('  ‚Ä¢ MongoDB: Rotate password in MongoDB Atlas')
    
    // GitHub Actions output
    if (process.env.GITHUB_ACTIONS) {
      console.log(`::set-output name=successful-rotations::${successful}`)
      console.log(`::set-output name=failed-rotations::${failed}`)
      console.log(`::set-output name=requires-manual-action::${failed > 0 ? 'true' : 'false'}`)
    }
  }
}

// Main execution
async function main() {
  const rotator = new SecretsRotator()
  const results = await rotator.rotateAllSecrets()
  
  rotator.generateReport()
  
  // Exit with error if any critical rotations failed
  const criticalFailures = results.filter(r => 
    !r.success && ['ENCRYPTION_KEY', 'JWT_SECRET', 'CLAUDE_API_KEY', 'OPENAI_API_KEY'].includes(r.secret)
  )
  
  if (criticalFailures.length > 0) {
    console.error('\nüí• Critical secret rotation failures detected!')
    process.exit(1)
  }
  
  console.log('\nüéâ Secrets rotation completed successfully!')
}

// Handle script execution
if (require.main === module) {
  main().catch(error => {
    console.error('üí• Secrets rotation failed:', error)
    process.exit(1)
  })
}

export { SecretsRotator, type RotationResult }